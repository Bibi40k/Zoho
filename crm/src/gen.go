package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"
	"time"

	zoho "github.com/schmorrison/Zoho"

	"github.com/ChimeraCoder/gojson"
	"github.com/Masterminds/sprig"
	"github.com/tidwall/gjson"
)

var schemas = []EndpointSchema{
	BlueprintSchema,
	ModulesSchema,
	NotesSchema,
}

var writers = map[string]io.Writer{}

func main() {
	for _, a := range schemas {
		var buf bytes.Buffer
		endpointTemplate.Execute(&buf, a)

		if _, ok := writers[a.Name]; !ok {
			f, err := os.Create(fmt.Sprintf("%s.gen.go", a.Name))
			if err != nil {
				log.Fatal("CREATE FILE: ", a.Name, err)
			}
			writers[a.Name] = f
		}

		if _, err := writers[a.Name].Write(buf.Bytes()); err != nil {
			log.Fatal("WRITE TO BUFFER: ", err)
		}
	}
}

var endpointTemplate = template.Must(
	template.New("").Funcs(sprig.TxtFuncMap()).Parse(`// Code generated by go generate; DO NOT EDIT.
// This Zoho CRM endpoint API was generated @ {{ printf "%s" .TimeStamp }}
package crm
{{ $name := .Name }}
{{- range .EndpointList }}
{{- range .Comments }}
// {{ printf "%s" . }}
{{- end }}
func (c *API) {{ .Endpoint.Name }}({{ if .Request }}{{ printf "request %s" .Request }}{{ if .Params }}, {{ end }}{{ end }}{{ .Params.Func }}) (data {{ .Response }}, err error) {
	endpoint := zoho.Endpoint{
		Name:         "{{ $name }}",
		URL:          fmt.Sprintf("https://www.zohoapis.%s{{ .Endpoint.URI }}", c.ZohoTLD{{ if .Params}}, {{ .Params.URI }}{{ end }}),
		Method:       {{ .Endpoint.HTTPMethod }},
		ResponseData: &{{ .Response }}{},
		{{- if .Request }}
		RequestBody: request,
		{{- end }}
		{{- if .Params.Map }}
		URLParameters: map[string]zoho.Parameter{
			{{ .Params.Map }}
		},
		{{- end }}
	}

	{{- if .Params.Includes "map" "params" }}

	if len(params) > 0 {
		for k, v := range params {
			endpoint.URLParameters[k] = v
		}
	}
	{{- end }}

	err = c.Zoho.HTTPRequest(&endpoint)
	if err != nil {
		return {{ .Response }}{}, fmt.Errorf("Failed to retrieve {{ $name }}: %s", err)
	}

	if v, ok := endpoint.ResponseData.(*{{ .Response }}); ok {
		return *v, nil
	}

	return {{ .Response }}{}, fmt.Errorf("Data returned was not '{{ .Response }}'")
}
{{- with .Request }}{{ .WriteStruct $name | trimPrefix "package crm" }}{{- end }}
{{- with .Response }}{{ .WriteStruct $name | trimPrefix "package crm" }}{{- end }}
{{- end }}
`))

type EndpointSchema struct {
	EndpointList
	Name string
}

func readJSON(name string) string {
	file, err := ioutil.ReadFile(fmt.Sprintf("src/%s.json", name))
	if err != nil {
		log.Fatal("READING JSON: ", name, err)
	}

	return string(file)
}

type EndpointList []EndpointSchemaBase

func (e EndpointList) TimeStamp() string {
	return time.Now().String()
}

type EndpointSchemaBase struct {
	Endpoint *Endpoint
	Params   EndpointParams
	Request  EndpointData
	Response EndpointData
	Comments []string
	Handlers struct {
		EndpointParams func(map[string]zoho.Parameter) (map[string]zoho.Parameter, error)
	}
}

type Endpoint struct {
	Name   string
	URI    string
	Method string
}

func (e *Endpoint) HTTPMethod() string {
	switch e.Method {
	case "GET":
		return "zoho.HTTPGet"
	case "POST":
		return "zoho.HTTPPost"
	case "PUT":
		return "zoho.HTTPPut"
	case "DELETE":
		return "zoho.HTTPDelete"
	default:
		return "zoho.HTTPGet"
	}
}

type EndpointParams []EndpointParam

type EndpointParam struct {
	Name string
	Type string
	Func bool
	URI  bool
	Map  bool
}

func (p EndpointParams) Func() string {
	vals := []string{}

	for _, a := range p {
		if a.Func {
			vals = append(vals, fmt.Sprintf("%s %s", a.Name, a.Type))
		}
	}

	return strings.Join(vals, ", ")
}

func (p EndpointParams) URI() string {
	vals := []string{}

	for _, a := range p {
		if a.URI {
			vals = append(vals, a.Name)
		}
	}
	return strings.Join(vals, ", ")
}

func (p EndpointParams) Map() string {
	vals := []string{}

	for _, a := range p {
		if a.Map {
			vals = append(vals, fmt.Sprintf("\"%s\": \"%s\",\n", a.Name, a.Type))
		}
	}

	return strings.Join(vals, "")
}

// ParamMap 	-
// ParamFunc	-
// ParamURI		-
const (
	ParamFunc = ParamTarget("Func")
	ParamMap  = ParamTarget("Map")
	ParamURI  = ParamTarget("URI")
)

type ParamTarget string

func (p EndpointParams) Includes(target ParamTarget, name string) bool {
	for _, a := range p {
		if a.Name == name {
			switch true {
			case target == ParamFunc && a.Func:
				return true
			case target == ParamMap && a.Map:
				return true
			case target == ParamURI && a.URI:
				return true
			}
		}
	}
	return false
}

// func (p *EndpointURIParams) sort() []int {
// 	m := *p
// 	var keys []int
// 	for k := range m {
// 		keys = append(keys, k)
// 	}
// 	sort.Ints(keys)
// 	return keys
// }

// func (p *EndpointURIParams) Keys() string {
// 	m := *p
// 	keys := m.sort()
// 	s := ""
// 	for _, k := range keys {
// 		v := m[k]
// 		kv := strings.Split(v.(string), ":")
// 		s += fmt.Sprintf(", %s", kv[0])
// 	}
// 	return s
// }
// func (p *EndpointURIParams) Format(request *EndpointData) string {
// 	m := *p
// 	keys := m.sort()
// 	s := ""
// 	if request != nil {
// 		s = fmt.Sprintf("request %s", request.Type)
// 	}
// 	ct := len(m) - 1
// 	for i, k := range keys {
// 		v := m[k]
// 		kv := strings.Split(v.(string), ":")
// 		if i < ct {
// 			s += ", "
// 		}
// 		s += fmt.Sprintf("%s %s", kv[0], kv[1])
// 	}
// 	return s
// }

type EndpointData string

func (e EndpointData) WriteStruct(module string) string {
	// get the "value" of the json data
	j := readJSON(module)
	res := gjson.Get(j, string(e))

	resAlias := res.Get("ALIAS")
	if resAlias.Exists() {
		alias := resAlias.String()
		return fmt.Sprintf("\n\ntype %s %s\n", e, alias)
	}

	parser := func(input io.Reader) (result interface{}, err error) {
		if result, err = gojson.ParseJson(input); err != nil {
			return nil, err
		}
		return result, nil
	}

	// convert to struct
	output, err := gojson.Generate(strings.NewReader(res.String()), parser, string(e), "crm", []string{"json"}, false, false)
	if err != nil {
		log.Fatal("GOJSON: ", e, err)
	}

	// include the omitempty
	return strings.Replace(string(output), "\"`", ",omitempty\"`", -1)
}
