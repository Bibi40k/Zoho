package zoho

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gorilla/mux"
)

type TestFailLevel int

const (
	TestFailNone  = 0 + iota // dont fail let the runTest handler make the decision
	TestFailWarn             // dont fail the test but log a warning
	TestFailError            // fail the test when an error occurs
)

type TestRoundTripper struct {
	Proxied        http.RoundTripper
	endpointConfig *TestEndpointExpects
}

func (zrt TestRoundTripper) RoundTrip(r *http.Request) (w *http.Response, err error) {
	u, err := r.URL.Parse(zohoTestServer.URL)
	if err != nil {
		zrt.endpointConfig.logError(fmt.Errorf("failed to parse url [%s]: %s", r.RequestURI, err))
	}

	// modify request to test server
	if !zrt.endpointConfig.roundTrip {
		r.URL.Scheme = u.Scheme
		r.URL.Host = u.Host
	}

	// check the http expectations for validity
	if zrt.endpointConfig.httpExpects.oauth.check {
		tokenGot := r.Header.Get("Authorization")
		tokenExpect := "Zoho-oauthtoken " + zrt.endpointConfig.httpExpects.oauth.token

		// check for overriding token
		if tokenGot != tokenExpect {
			zrt.endpointConfig.logError(fmt.Errorf("invalid token found in request header [%s]: %s -> %s", r.RequestURI, tokenGot, tokenExpect))
		}
	}

	w, err = zrt.Proxied.RoundTrip(r)
	if err != nil {
		zrt.endpointConfig.logError(fmt.Errorf("roundtrip request failed [%s]: %s", r.RequestURI, err))
	}
	return
}

type TestEndpointExpects struct {
	t           *testing.T
	fail        TestFailLevel // the desired fail level
	roundTrip   bool          // enable roundtrip to Zoho server
	httpExpects struct {
		uris  []*TestZohoEndpoint // all uris that will be inspected
		oauth struct {
			check bool   // oauth check is enabled
			token string // expected token
		}
	}

	complete chan bool // used to signal the test is complete
	start    chan bool // used to signal the test is starting
}

func NewEndpointTestGroup(t *testing.T) *TestEndpointExpects {
	return &TestEndpointExpects{t: t, complete: make(chan bool), start: make(chan bool)}
}

// run the test functions
func (zt *TestEndpointExpects) Exec(fn func(*testing.T)) {
	fn(zt.t)
}

// run the test function async
func (zt *TestEndpointExpects) ExecAsync(fn func(*testing.T)) {
	go func() {
		fn(zt.t)
	}()
}

// add uris to the list of uris that will be inspected
func (zt *TestEndpointExpects) URI(uris []*TestZohoEndpoint) *TestEndpointExpects {
	zt.httpExpects.uris = append(zt.httpExpects.uris, uris...)
	return zt
}

// enable oauth check
func (zt *TestEndpointExpects) OAuth() *TestEndpointExpects {
	zt.httpExpects.oauth.check = true
	return zt
}

// override the default token generated by the request function
func (zt *TestEndpointExpects) Token(token string) *TestEndpointExpects {
	zt.httpExpects.oauth.token = token
	return zt
}

// set the faillevel
func (zt *TestEndpointExpects) Fail(level TestFailLevel) *TestEndpointExpects {
	zt.fail = level
	return zt
}

// enable full round trip
func (z *TestEndpointExpects) RoundTrip() *TestEndpointExpects {
	z.roundTrip = true
	return z
}

// log error and fail the test if faillevel is set to TestFailError
func (z *TestEndpointExpects) logError(err error) {
	if err != nil {
		switch z.fail {
		case TestFailWarn:
			z.t.Logf("WARNING -- %s", err)
		case TestFailError:
			z.t.Errorf("FAILED -- %s", err)
		}
	}
}

type TestZohoEndpoint struct {
	uri string
	// the body (struct, string, file) that is sent to the Zoho API
	// without roundtrip the value will be sent to the local http test server and check that this properly matches the body in the http request
	// this value will also be sent to the MockRequest function if provided
	// with roundtrip this value will also be sent to the Zoho API
	RequestExpect interface{}
	RequestFormat BodyFormatter

	// the response that is expected from the Zoho API
	// without roundtrip the expexcted response will be returned as the value of the http response
	// this value will be checked against the http response body when MockRequest returns
	// with roundtrip this value will be checked against the http response body when the Zoho API returns
	ResponseExpect interface{}
	OnRequest      func(*testing.T, *http.Request, error) error // the client roundtrip intercept
	MockRequest    func(http.ResponseWriter, *http.Request)     // the mock HTTP request handler
}

// the configuration of a test endpoint, used to catch the request and response
// uri can be a gorilla mux route to catch multiple similar uris
// unhandled routes will throw an error
func NewTestEndpoint(uri string) *TestZohoEndpoint {
	return &TestZohoEndpoint{
		uri:           uri,
		RequestFormat: &NullFormatter{},
	}
}

// set the expected request body and format
func (zt *TestZohoEndpoint) Request(rex interface{}, rf BodyFormatter) *TestZohoEndpoint {
	zt.RequestExpect = rex
	zt.RequestFormat = rf
	return zt
}

// set the expected response body
func (zt *TestZohoEndpoint) Response(rex interface{}) *TestZohoEndpoint {
	zt.ResponseExpect = rex
	return zt
}

func (zt *TestZohoEndpoint) SetOnRequest(fn func(*testing.T, *http.Request, error) error) *TestZohoEndpoint {
	zt.OnRequest = fn
	return zt
}

func (zt *TestZohoEndpoint) SetMockRequest(fn func(http.ResponseWriter, *http.Request)) *TestZohoEndpoint {
	zt.MockRequest = fn
	return zt
}

var zohoTestServer *httptest.Server

// create a test client/server for intercepting the HTTP request/response
func (z *Zoho) TestHTTPClient(endpointConfig *TestEndpointExpects) {
	// check for overriding token
	if endpointConfig.httpExpects.oauth.token == "" && endpointConfig.httpExpects.oauth.check {
		endpointConfig.httpExpects.oauth.token = z.oauth.token.AccessToken
	}

	if !endpointConfig.roundTrip {
		r := mux.NewRouter()
		for _, a := range endpointConfig.httpExpects.uris {
			r.HandleFunc(a.uri, func(w http.ResponseWriter, r *http.Request) {
				// type check for request bodyformat
				reader, ct, err := a.RequestFormat.Format(a.RequestExpect)
				if err != nil {
					endpointConfig.logError(fmt.Errorf("failed to format expected request body [%s]: %s", a.uri, err))
				}

				// check content type header
				if ct != r.Header.Get("Content-Type") {
					endpointConfig.logError(fmt.Errorf("content type header received does not match expects [%s]: %s", a.uri, ct))
				}

				// read expected body
				expectBody, err := ioutil.ReadAll(reader)
				if err != nil {
					endpointConfig.logError(fmt.Errorf("failed to read expected body from buffer [%s]: %s", a.uri, err))
				}

				// read the request body
				gotBody, err := ioutil.ReadAll(r.Body)
				if err != nil {
					endpointConfig.logError(fmt.Errorf("failed to read expected body from request buffer [%s]: %s", a.uri, err))
				}

				// compare the expected body to request body
				if !bytes.Equal(expectBody, gotBody) {
					endpointConfig.logError(fmt.Errorf("expected body does not match got body [%s]: %s", a.uri, string(expectBody)))
				}

				if a.OnRequest != nil {
					err = a.OnRequest(endpointConfig.t, r, nil)
					if err != nil {
						endpointConfig.logError(err)
					}
				}

				// execute the mock request on the values
				if a.MockRequest != nil {
					a.MockRequest(w, r)
					return
				}

				// write the response
				w.Header().Set("Content-Type", ct)
				err = json.NewEncoder(w).Encode(a.ResponseExpect)
				if err != nil {
					endpointConfig.logError(fmt.Errorf("failed to write response [%s]: %s", a.uri, err))
				}
			})
		}

		r.PathPrefix("/").HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
			// all unhandled routes should be counted and logged
			endpointConfig.logError(fmt.Errorf("unhandled route [%s]", r.URL.String()))
		})

		zohoTestServer = httptest.NewServer(r)
		// Close the server when test finishes
		z.CustomHTTPClient(zohoTestServer.Client())

		go func() {
			<-endpointConfig.complete
			zohoTestServer.Close()
			fmt.Println("test server closed")
		}()
	}
	z.client.Transport = TestRoundTripper{http.DefaultTransport, endpointConfig}
}
